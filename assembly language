# 어셈블리어

## 어셈블리어 란?

 : 기계어와 일대일 대응되는 컴퓨터 프로그래밍의 저급 언어

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/297dedab-846e-4c7e-8e50-178966b0bd65/Untitled.png)

컴퓨터 구조에 따라 사용되는 기계어가 달라지며 대응되는 어셈블리어도 각각 다르다

컴퓨터 cpu마다 지원하는 오퍼레이션 타입과 개수는 제각각이며, 레지스터의 크기와 개수, 저장된 데이터 형의 표현도 각각 다르다.

- 어셈블러
    
    : 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해주는 컴퓨터 언어번역 프로그램
    
      하나의 어셈블리어 명령어는 하나의 기계 코드에 대응
    

- 어셈블리어
    
    : 동일한 종류의 프로세서만 실행 가능
    
      프로세서에 대한 사전 지식 필요
    
      메모리 입출장치, 레지스터 등의 구성요소들을 직접 다룰 수 있음
    
      컴퓨터에서 실행하는 과정들을 이해하기 쉬움
    
      컴퓨터 성능에 최적인 프로그램 작성 가능
    

### 어셈블러의 종류

- MSAM - Windows
- GAS - Linux/Unix
- NSAM - Windows, Linux, MAC
- SASM - Windows, Linux

### 레지스터 란?

 : CPU의 요청을 처리하는 데이터의 임시공간

공간이 작고 비싸지만 CPU와 직접 연결되어 있어 연산 속도 매우 빠름

### **범용 레지스터**

![https://blog.kakaocdn.net/dn/JUiRe/btqTwX4wGwL/SKem3pBWVmRmlCnChbcYE0/img.png](https://blog.kakaocdn.net/dn/JUiRe/btqTwX4wGwL/SKem3pBWVmRmlCnChbcYE0/img.png)

EAX : 산술 연산, 함수의 반환 값

EBX : 간접 번지 지정, 산수, 변수 저장

ECX : 반복문 count 역할

EDX : EAX 보조, 나누기 연산에서 몫은 EAX, 나머지는 EDX

### **인덱스 레지스터**

![https://blog.kakaocdn.net/dn/bloszf/btqTtpNZRiR/UlMAbppIIQB5DqqAqlXGBK/img.png](https://blog.kakaocdn.net/dn/bloszf/btqTtpNZRiR/UlMAbppIIQB5DqqAqlXGBK/img.png)

**ESI :** 복사, 비교를 시 출발지 주소를 저장

**EDI :** 복사, 비교를 시 목적지 주소를 저장

### **포인터 레지스터**

![https://blog.kakaocdn.net/dn/cYVSuw/btqTvQEvc1O/K6scRfzpuRB5Nm9TVDoxP1/img.png](https://blog.kakaocdn.net/dn/cYVSuw/btqTvQEvc1O/K6scRfzpuRB5Nm9TVDoxP1/img.png)

**EIP :** 다음에 실행할 명령어의 주소 저장

**ESP :** Stack Pointer의 가장 최근에 저장된 공간의 주소를 저장

**EBP :** Stack Pointer의 기준점(바닥 부분)을 저장

### 플레그 레지스터

**OF** (Overflow Flag) : 부호 있는 수 끼리 연산. 연산 결과 용량 초과 시 참

**SF** (Sign Flag) : 최상위 비트가 1이면 참

**ZF** (Zero Flag) : 연산 결과가 0이라면 참

**AF** (Auximiliary Flag) : 16비트 연산 시 자리올림, 자리내림 발생 시 참

**PF** (Parity Flag) : 연산 결과 짝수 시 참

**DF** (Direction Flag) : 문자열 조작에서 참일 경우 주소 레지스터 값 자동 감소, 거짓이면 자동 증가

**IF** (Interrupt Flag) : 이 플래그가 참일 경우메낭 인터럽 요구 받아들임

**TF** (Trap Flag) : 참일 경우 한 명령 실행마다 인터럽 발생. (디버깅에 사용)

### 어셈블리어 자료형

Byte : 1바이트 = char

Word : 2바이트 = short

Dword : 4바이트 = int

Qword : 8바이트 = double

### 어셈블리어 명령어

### **Data Transfer**

| 명령어 |  | 설명 |
| --- | --- | --- |
| MOV | Move | 데이터 이동 (전송) |
| PUSH | Push | 오퍼랜드의 내용에 스택을 쌓는다. |
| POP | Pop | 스택으로부터 값을 뽑아낸다. |
| IN | Input from AL/AX to Fixed port | 오퍼랜드로 지시된 포트로부터 AX에 데이터 입력 |
| OUT | Output from AL/AX to Fixed port | 오퍼랜드가 지시한 포트로 AX의 데이터 출력 |

### **Arithmetic**

| 명령어 |  | 설명 |
| --- | --- | --- |
| ADD | Add | 캐리를 포함하지 않은 덧셈 |
| SBB | Subtract with Borrow | 캐리를 포함한 뺄셈 |
| DEC | Decrement | 오퍼랜드 내용을 1 감소 |
| NEG | Change Sign | 오퍼랜드의 2의 보수, 즉 부호 반전 |
| CMP | Compare | 두 개의 오퍼랜드를 비교한다 |
| ADC | Add with Carry | 캐리를 포함한 덧셈 |
| INC | Increment | 오퍼랜드 내용을 1 증가 |
| SUB | Subtract | 캐리를 포함하지 않은 뺄셈 |
| MUL | Multiply (Unsigned) | AX와 오퍼랜드를 곱셈하여 결과를 AX 또는 DX:AX에 저장 |
| IMUL | Integer Multiply (Signed) | 부호화된 곱셈 |

### **Logic**

| 명령어 |  | 설명 |
| --- | --- | --- |
| NOT | Invert | 오퍼랜드의 1의 보수, 즉 비트 반전 |
| AND | And | 논리 AND |
| OR | Or | 논리 OR |
| XOR | Exclusive Or | 배타 논리 합 (OR) |

### **Control Transfer**

| 명령어 |  | 설명 |
| --- | --- | --- |
| CALL | Call | 프로시저 호출 |
| JMP | Unconditional Jump | 무조건 분기 |
| RET | Return from CALL | CALL로 스택에 PUSH된 주소로 복귀 |
| JE/JZ | Jump on Equal / Zero | 결과가 0이면 분기 |
| JL/JNGE | Jump on Less / not Greater or Equal | 결과가 작으면 분기 (부호화된 수) |
| JB/JNAE | Jump on Below / not Above or Equal | 결과가 작으면 분기 (부호화 안 된 수) |
| JBE/JNA | Jump on Below or Equal / not Above | 결과가 작거나 같으면 분기 (부호화 안 된 수) |
| JP/JPE | Jump on Parity / Parity Even | 패리티 플레그가 1이면 분기 |
| JNE/JNZ | Jump on not Equal / not Zero | 결과가 0이 아니면 분기 |
| JNL/JGE | Jump on not Less / Greater or Equal | 결과가 크거나 같으면 분기 (부호화된 수) |
| JNLE/JG | Jump on not Less or Equal / Greater | 결과가 크면 분기 (부호화된 수) |
| JNB/JAE | Jump on not Below / Above or Equal | 결과가 크거나 같으면 분기 (부호화 안 된 수) |
| JNBE/JA | Jump on not Below or Equal / Above | 결과가 크면 분기 (부호화 안 된 수) |
| JNP/JPO | Jump on not Parity / Parity odd | 패리티 플레그가 0이면 분기 |
| LOOP | Loop CX times | CX를 1감소하면서 0이 될 때까지 지정된 라벨로 분기 |

XOR → 0을 표현하는 가장 크기가 적은 명령어 4byte

MOV → 6byte  MOV ECX, 0 → 거의 없음.
